! ploDataElem is a post-processing software for T+H (TOUGH HYDRATE) program.
! It reads plot_data_elem file generated by T+H simulations and converts them
! vtu format. Which can then be visualized by usign PARAVIEW and other
! softwares.
!
! Copyright (C) 2020-2021  Vikas Sharma, Ph.D
!
! This program is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <https: //www.gnu.org/licenses/>
!

!> authors: Vikas Sharma, Ph. D.
! date: 	27 Feb 2021
! summary: 	File data type and its methods are defined

MODULE File_Class
USE PENF
USE StringiFor
IMPLICIT NONE

PRIVATE

INTEGER( I4P ), PARAMETER :: I4B = I4P
REAL( R4P ), PARAMETER :: DFP = R4P
INTEGER, PARAMETER      :: LGT = KIND(.true.)       !Logical
TYPE( String ), PARAMETER, PUBLIC :: TypeString = String( raw = NULL() )

!----------------------------------------------------------------------------
!                                                                      File_
!----------------------------------------------------------------------------

TYPE :: File_
  TYPE( String ) :: FileName, Path, Extension, ACTION, STATUS, ACCESS
  INTEGER( I4B ) :: UnitNo, WriteNo, IOSTAT
  LOGICAL( LGT ) :: isOpen
END TYPE File_

PUBLIC :: File_

TYPE( File_ ), PUBLIC, PARAMETER :: TypeFile = &
  & File_( FileName = TypeString, Path = TypeString, Extension = TypeString, &
  & ACTION = TypeString, STATUS = TypeString, ACCESS = TypeString, &
  & UnitNo = -1, WriteNo = -1, IOSTAT = -1, isOpen = .FALSE. )

TYPE :: FilePointer_
  CLASS( File_ ), POINTER :: Ptr => NULL( )
END TYPE FilePointer_

PUBLIC :: FilePointer_

!----------------------------------------------------------------------------
!                                                        Initiate@Constructor
!----------------------------------------------------------------------------

INTERFACE
MODULE SUBROUTINE init_file( Obj, Path, FileName, Extension, Status, &
  & Action, Access )
CLASS( File_ ), INTENT( INOUT ) :: Obj
CHARACTER( LEN = * ), INTENT( IN ) :: Path, FileName, Extension, Status, &
  & Action
CHARACTER( LEN = * ), INTENT( IN ), OPTIONAL ::  Access
END SUBROUTINE init_file
END INTERFACE

INTERFACE Initiate
  MODULE PROCEDURE init_file
END INTERFACE Initiate

PUBLIC :: Initiate

!----------------------------------------------------------------------------
!                                                          File@Constructor
!----------------------------------------------------------------------------

INTERFACE
MODULE FUNCTION Constructor1(  ) RESULT( Ans )
  TYPE( File_ ) :: Ans
END FUNCTION Constructor1
END INTERFACE

INTERFACE File
  MODULE PROCEDURE Constructor1
END INTERFACE

PUBLIC :: File

!----------------------------------------------------------------------------
!                                                       File_Pointer@Contains
!----------------------------------------------------------------------------

INTERFACE File_Pointer
  MODULE PROCEDURE Constructor_1
END INTERFACE

PUBLIC :: File_Pointer

!----------------------------------------------------------------------------
!                                                        OpenFile@Constuctor
!----------------------------------------------------------------------------

INTERFACE
MODULE SUBROUTINE open_file( Obj )
  CLASS( File_ ), INTENT( INOUT ) :: Obj
END SUBROUTINE open_file
END INTERFACE

INTERFACE OpenFile
  MODULE PROCEDURE open_file
END INTERFACE OpenFile

PUBLIC :: OpenFile

!----------------------------------------------------------------------------
!                                                            OpenFileToWrite
!----------------------------------------------------------------------------

INTERFACE
MODULE SUBROUTINE open_file_write_a( Obj, Path, FileName, Extension )
  CLASS( File_ ), INTENT( INOUT ) :: Obj
	CHARACTER( LEN = * ), INTENT( IN ) :: Path, FileName, Extension
END SUBROUTINE open_file_write_a
END INTERFACE

INTERFACE
MODULE SUBROUTINE open_file_write_b( Obj, PFE )
  CLASS( File_ ), INTENT( INOUT ) :: Obj
	TYPE( String ), INTENT( IN ) :: PFE( : )
END SUBROUTINE open_file_write_b
END INTERFACE

INTERFACE
MODULE SUBROUTINE open_file_write_c( Obj, Path, FileName, Extension )
  CLASS( File_ ), INTENT( INOUT ) :: Obj
	TYPE( String ), INTENT( IN ) :: Path, FileName, Extension
END SUBROUTINE open_file_write_c
END INTERFACE

INTERFACE OpenFileToWrite
  MODULE PROCEDURE open_file_write_a, open_file_write_b, open_file_write_c
END INTERFACE OpenFileToWrite

PUBLIC :: OpenFileToWrite

!----------------------------------------------------------------------------
!                                                            OpenFileToRead
!----------------------------------------------------------------------------

INTERFACE
MODULE SUBROUTINE open_file_Read_a( Obj, Path, FileName, Extension )
  CLASS( File_ ), INTENT( INOUT ) :: Obj
	CHARACTER( LEN = * ), INTENT( IN ) :: Path, FileName, Extension
END SUBROUTINE open_file_Read_a
END INTERFACE

INTERFACE
MODULE SUBROUTINE open_file_Read_b( Obj, PFE )
  CLASS( File_ ), INTENT( INOUT ) :: Obj
	TYPE( String ), INTENT( IN ) :: PFE( : )
END SUBROUTINE open_file_Read_b
END INTERFACE

INTERFACE
MODULE SUBROUTINE open_file_Read_c( Obj, Path, FileName, Extension )
  CLASS( File_ ), INTENT( INOUT ) :: Obj
	TYPE( String ), INTENT( IN ) :: Path, FileName, Extension
END SUBROUTINE open_file_Read_c
END INTERFACE

INTERFACE OpenFileToRead
  MODULE PROCEDURE open_file_Read_a, open_file_Read_b, open_file_Read_c
END INTERFACE OpenFileToRead

PUBLIC :: OpenFileToRead

!----------------------------------------------------------------------------
!                                                            OpenFileToAppend
!----------------------------------------------------------------------------

INTERFACE
MODULE SUBROUTINE open_file_Append_a( Obj, Path, FileName, Extension )
  CLASS( File_ ), INTENT( INOUT ) :: Obj
	CHARACTER( LEN = * ), INTENT( IN ) :: Path, FileName, Extension
END SUBROUTINE open_file_Append_a
END INTERFACE

INTERFACE
MODULE SUBROUTINE open_file_Append_b( Obj, PFE )
  CLASS( File_ ), INTENT( INOUT ) :: Obj
	TYPE( String ), INTENT( IN ) :: PFE( : )
END SUBROUTINE open_file_Append_b
END INTERFACE

INTERFACE
MODULE SUBROUTINE open_file_Append_c( Obj, Path, FileName, Extension )
  CLASS( File_ ), INTENT( INOUT ) :: Obj
	TYPE( String ), INTENT( IN ) :: Path, FileName, Extension
END SUBROUTINE open_file_Append_c
END INTERFACE

INTERFACE OpenFileToAppend
  MODULE PROCEDURE open_file_Append_a, open_file_Append_b, open_file_Append_c
END INTERFACE OpenFileToAppend

PUBLIC :: OpenFileToAppend

!----------------------------------------------------------------------------
!                                                                  CloseFile
!----------------------------------------------------------------------------

INTERFACE
MODULE SUBROUTINE close_file( Obj )
  CLASS( File_ ), INTENT( INOUT ) :: Obj
END SUBROUTINE close_file
END INTERFACE

INTERFACE CloseFile
  MODULE PROCEDURE close_file
END INTERFACE CloseFile

PUBLIC :: CloseFile

!----------------------------------------------------------------------------
!                                                                 ReopenFile
!----------------------------------------------------------------------------

INTERFACE
MODULE SUBROUTINE reopen_file( Obj )
  CLASS( File_ ), INTENT( INOUT ) :: Obj
END SUBROUTINE reopen_file
END INTERFACE

INTERFACE ReopenFile
  MODULE PROCEDURE reopen_file
END INTERFACE ReopenFile

PUBLIC :: ReopenFile

!----------------------------------------------------------------------------
!                                                                    Contains
!---------------------------------------------------------------------------
Contains

FUNCTION Constructor_1( ) RESULT( Obj )
  ! Define intent of dummy variables
  CLASS( File_ ), POINTER :: Obj
  ALLOCATE( Obj )
  Obj % isOpen = .FALSE.
  END FUNCTION Constructor_1

END MODULE File_Class